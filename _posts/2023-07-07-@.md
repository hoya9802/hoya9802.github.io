---
layout: single
title:  "[Python] 데코레이터(@)"
typora-root-url: ../
categories: Python
tag: [Python]
author_profile: false
sidebar:
    nav: 'counts'
search: true
use_math: true
redirect_from:
  - /python/decorator
published: false
---

## 데코레이터란

Python 데코레이터(decorator)는 함수 또는 메서드의 동작을 수정하거나 확장하는 방법을 제공하는 고급 기능입니다. 데코레이터는 다른 함수나 메서드를 인수로 받아, 그 함수나 메서드의 앞뒤로 추가적인 동작을 수행한 뒤 원래의 함수나 메서드를 반환합니다.

## 데코레이터의 기본 구조

데코레이터 함수 정의: 데코레이터는 일반적으로 함수를 감싸는 함수로 정의됩니다.<br>
<br>
데코레이터 적용: 데코레이터는 함수 정의 바로 위에 <span style='color:yellow'>**@데코레이터 이름**</span> 형태로 적용됩니다.
{: .notice}

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator   # @데코레이터 이름(my_decorator)
def say_hello():
    print("Hello!")

say_hello()
```

이 예제에서는 say_hello 함수에 my_decorator 데코레이터가 적용되어, say_hello 함수가 호출될 때마다 데코레이터가 정의한 추가 동작이 실행됩니다.

## 데코레이터 다양한 활용 방법

### 데코레이터가 인자를 받는 경우

```python
def repeat(num_times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello!")

say_hello()
```

설명

데코레이터 팩토리 (repeat):

repeat 함수는 num_times 인자를 받아 데코레이터를 반환합니다.
decorator 함수는 func를 인수로 받아 wrapper 함수를 정의합니다.

데코레이터 적용:

@repeat(3)을 사용하여 say_hello 함수에 데코레이터를 적용합니다. 이는 repeat(3)이 decorator 함수를 반환하고, decorator(say_hello)가 실행되어 wrapper 함수를 반환하는 것과 같습니다.

함수 실행:

say_hello 함수가 호출될 때마다 wrapper 함수가 실행되며, 이 함수는 num_times만큼 func를 호출합니다.

## 데코레이터의 사용 사례

로깅(Logging): 함수가 호출될 때마다 로그를 남기는 데코레이터를 만들어 사용할 수 있습니다.<br>
<br>
성능 측정(Timing): 함수 실행 시간을 측정하여 성능을 모니터링하는 데 유용합니다.<br>
<br>
접근 제어(Access Control): 사용자의 권한을 확인하여 함수 접근을 제어할 수 있습니다.<br>
<br>
캐싱(Caching): 함수의 반환값을 캐시하여 동일한 입력에 대해 중복 계산을 피할 수 있습니다.<br>
{: .notice style='background-color:black'}
